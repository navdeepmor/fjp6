<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
                                                            /* ------ this keyword ----- */
// console.log("outside", this);                                                                           // windows                                                     in this line we didn't have any object but there is one global obj which running the whole code incase of browser it's windows | this keyword referes to current object | here we talking about this keyword in browser ent. and non-stict mode

// function fn() {                                                                                         // in functions, this => obj through which function is call i.e. the object in who's context fn being call or the one who calls the fn | in shot the curr obj in curr funciton    
//     console.log("inside fn", this);                                                                     // windows
// }
// fn();                                                                                                   // in this function call we haven't passed any object thus this function call would in global object 

// let obj = {
//     name: "Lalu",
//     func: fn
// }
// obj.func();                                                                                             // self object

// function fn1() {
//     console.log(this);                                                                                      // it will get the obj1 therefore with printing this keyword it will give us obj1
//     function fn2() {
//         console.log(this);                                                                                  // again it being call directly with at line 32 fn2(); where it doesn't have any object thus it will display global object i.e. windows in case of browser when we would console inside the function.
//     }
//     fn2();
// }

// let obj1 = {
//     name: "Aalu",
//     func: fn1
// }
// obj1.func();   
                     
                                                          /* ----- METHOD 1: bind function ----- */
// function fn1() {
//     console.log(this);
//     function fn2() {
//         console.log(this);
//     }
//     let fnDef = fn2.bind(this);                                                                                 // bind() it return function def
//     fnDef();
// }

// let obj1 = {
//     name: "Bhalu",
//     func: fn1
// }

// obj1.func();

                                                          /* ----- METHOD 2: arrow function ----- */
function fn1() {
    console.log(this);
    fn2 = () => {
        console.log(this);                                                                                          // it take the global obj i.e. windows as we haven't constructed fn2 fn using function keyword then it see's it own this but when we use arrow function then it doesn't have it's own this therefore it will make it's parent this it's own this which is it's default property
    }
    fn2();
}

let obj1 = {
    name: "Bhalu",
    func: fn1
}

obj1.func();

</script>
</html>